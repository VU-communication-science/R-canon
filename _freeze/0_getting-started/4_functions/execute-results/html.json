{
  "hash": "3df811fb64c81b71141230407a5bc1c8",
  "result": {
    "markdown": "---\ntitle: Functions\n---\n\n\n99% of what you do in R will involve using functions. \nA function in R is like a mini-program that you can use to perform specific tasks. \nIt takes *input*, processes it, and gives you an *output*. \nFor example, there are functions for:\n\n* importing data \n* computing descriptive statistics\n* performing statistical tests\n* visualizing data\n\nA function in R has the form: `output = function_name(argument1, argument2, ...)`\n\n* **function_name** is a name to indicate which function you want to use. It is followed by parentheses.\n* **arguments** are the input of the function, and are inserted within the parentheses. \n* **output** is anything that is returned by the function. \n\nFor example, the function `c` *c*ombines multiple values into a *vector*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1,2,3,4)\n```\n:::\n\n\nNow, we can use the `mean` function to calculate the mean of these numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = mean(x)\n```\n:::\n\n\nThe calculated mean, `2.5`, is now assigned to the name `m`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n:::\n\n\n## Optional arguments\n\nIn the `c` and `mean` functions above, all the arguments were **required**. \nTo **c**ombine numbers into a vector, we *needed* to provide a list of numbers.\nTo calculate a **mean**, we *needed* to provide a numeric vector.\n\nIn addition to the **required** arguments, a function can also have **optional** arguments, that give you more control over what a function does.\nFor example, suppose we have a range of numbers that also contains a missing value. In R a missing value is called `NA`, which stands for `Not Available`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_with_missing = c(1, 2, 3, NA, 4)\n```\n:::\n\n\nNow, if we call the `mean` function, R will say that the mean is unknown, since the third value is unknown:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x_with_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThis is statistically a very correct answer.\nBut often, if some values happen to be missing in your data, you want to be able to calculate the mean just for the numbers that are not missing.\nFortunately, the mean function has an **optional argument** `na.rm` (remove NAs) that you can set to `TRUE` (or to `T`, which is short for `TRUE`) to ignore the NAs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n:::\n\n\nNotice that for the **required** argument, we directly provide the input `x`, but for the **optional** argument we include the argument name `na.rm = TRUE`.\nThe reason is simply that there are other optional arguments, so we need to specify which one we're using.\n\n::: {.callout-note title=\"How do I know what arguments a function has?\" collapse=\"true\"}\n\nTo learn more about what a function does and what arguments it has, you can look it up in the 'Help' pane in the bottom right, \nor run `?function_name` in R. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\n```\n:::\n\n\nHere you can learn about the `na.rm` argument that we just used!\n\nIf you are just getting to know R, we recommend first finishing the rest of the `Getting Started` section. \nThen once you get the hang of things, have a look at the [Use ?function help page](99_tips-and-best-practises/0_use-help-pages.qmd) tutorial.\n:::\n\n\n## Using pipes\n\nThere are two ways for using functions.\n\n* The first is the one shown above, where we **put all the arguments between the parentheses**: `function_name(argument1, argument2, ...)`.\n* The second way is to **pipe the first argument into the function**: `argument1 |> function_name(argument2, ...)`\n\nIf this is your first time seeing pipes, you're probably wondering why you would want to do this?\nWhy bother having two ways to do the exact same thing?\nThe reason is that when writing code, you shouldn't just think about **what the code does**, but also about **how easy the code is to read**.\nThis not only helps you prevent mistakes, but also makes your analysis **transparent**.\n\nAs you'll see later, you'll encounter many cases where your analysis requires you to string together multiple functions.\nIn these cases, pipes make your code much easier to read.\nlet's rewrite our code from above using the **pipe** notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_with_missing |> mean(na.rm=T)\n```\n:::\n\nNotice how our first argument, the **required** argument `x_with_missing`, is *piped* into the mean function.\nInside the mean function, we only specify the second argument, the **optional** argument `na.rm`.\n\nNow imagine we would want to round the result (`2.5`) up to a round number (`3`). \nWe can do this without pipe notation, but it would be quite ugly and hard to read:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(mean(x_with_missing, na.rm=T))\n```\n:::\n\nThe pipe notation allows us to break this down into a nice pipeline:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_with_missing |> \n  mean(na.rm=T) |> \n  round()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}