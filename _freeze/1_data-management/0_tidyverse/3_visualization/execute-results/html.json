{
  "hash": "4b8a49e7117f6841fdceeb37cdf11b92",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualization basics\"\n---\n\n\n\n\nThis tutorial teaches the basics of data visualization using the `ggplot2` package (included in `tidyverse`). \nFor more information, see [R4DS Chapter 3: Da`ta Visualization](http://r4ds.had.co.nz/data-visualisation.html) and  [R4DS Chapter 7: Exploratory Data Analysis](http://r4ds.had.co.nz/exploratory-data-analysis.html).\n\nFor *many* cool visualization examples using `gplot2` (with R code included!) see the [R Graph Gallery](https://www.r-graph-gallery.com/portfolio/ggplot2-package/).\nFor inspiration (but unfortunately no R code), there is also a [538 blog post on data visualization from 2016](https://fivethirtyeight.com/features/the-52-best-and-weirdest-charts-we-made-in-2016/).\nFinally, see the article on '[the grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html)' published by Hadley Wickham for more insight into the ideas behind ggplot.\n\n# A Basic ggplot plot\n\nSuppose that we want to see the relation between college education and household income, both included in the `county facts` subset published by  [Houston Data Visualisation github page](https://github.com/houstondatavis/data-jam-august-2016).\nSince this data set contains a large amount of columns, we keep only a subset of columns for now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nurl <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/county_facts.csv\"\nfacts <- read_csv(url) \nfacts_subset <- facts %>% \n  select(fips, area_name, state_abbreviation, \n         population = Pop_2014_count, \n         pop_change = Pop_change_pct,\n         over65 = Age_over_65_pct, \n         female = Sex_female_pct,\n         white = Race_white_pct,\n         college = Pop_college_grad_pct, \n         income = Income_per_capita)\nfacts_state <- facts_subset %>% \n  filter(is.na(state_abbreviation) & fips != 0) %>% \n  select(-state_abbreviation)\nfacts_state\n```\n:::\n\n\nNow, let's make a *scatter plot* with percentage college-educated on the x-axis and median income on the y-axis. First, we can used the function `ggplot` to create an empty canvas tied to the dataset `facts_state` and tell the function which variables to use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state,        # which data set?\n       aes(x=college, y=income))  # which variables as aesthetics?\n```\n:::\n\n\nNext, we need to tell ggplot what to plot. In this case, we want to produce a scatterplot. The function `geom_point` adds a layer of information to the canvas. In the language of ggplot, each layer has a *geometrical representation*, in this case \"points\". In this case, the \"x\" and \"y\" are mapped to the college and income columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state,\n       mapping = aes(x = college, y = income)) + \n  geom_point()   # adding the geometrical representation\n```\n:::\n\n\nSo called *aesthetic mappings*, which map the visual elements of the geometry to columns of the data, can also be included as argument in the `geom`. This can be handy when several `geoms` are plotted and different aesthetics are used. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# same plot as above\nggplot(data = facts_state) + \n  geom_point(mapping = aes(x = college, y = income)) \n```\n:::\n\n\nThe result is a plot where each point here represents a state, and we see a clear correlation between education level and income. There is one clear outlier on the top-right. Can you guess which state that is?\n\nDue to the layer logic of ggplot, we can add more `geoms` to the plot (e.g., a regression line). \nRemember that if we provide aesthetics within the `ggplot`-function, these are passed to all `geoms`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loess curve\nggplot(data = facts_state, \n       mapping = aes(x = college, y = income)) + \n  geom_point() +\n  geom_smooth() \n\n# Linear regression line\nggplot(data = facts_state, \n       mapping = aes(x = college, y = income)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n\n## Important note on ggplot command syntax\n\nFor the plot to work, R needs to execute the whole ggplot call and all layers as a single statement.\nPractically, that means that if you combine a plot over multiple lines, the plus sign needs to be at the end of the line, so R knows more is coming. The general syntax is always:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))\n```\n:::\n\n\n\nSo, the following is good:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(mapping = aes(x = college, y = income))\n```\n:::\n\n\nBut this is not:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) \n  + geom_point(mapping = aes(x = college, y = income))\n```\n:::\n\n\nAlso note that the data and mapping arguments are the first arguments the functions expect, so you can also leave them out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(facts_state) + \n  geom_point(aes(x = college, y = income))\n```\n:::\n\n\n## Other aesthetics  \n\nTo find out which visual elements can be used in a layer, use e.g. `?geom_point`. According to the help file, we can (among others) set the colour, alpha (transparency), and size of points.\nLet's first set the size of points to the (log) population of each state, creating a bubble plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x = college, y = income, size = population))\n```\n:::\n\n\nSince it is difficult to see overlapping points, let's make all points somewhat transparent. \nNote: Since we want to set the alpha of all points to a single value, this is not a mapping (as it is not mapped to a column from the data frame), but a constant.\nThese are set outside the mapping argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x = college, y = income, size = population), \n             alpha = .5, \n             colour = \"red\")\n```\n:::\n\n\nInstead of setting colour to a constant value, we can also let it vary with the data. For example, we can colour the states by percentage of population that is identified as 'white':\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x=college, y=income, size=population, colour=white), \n             alpha=.9)\n```\n:::\n\n\nFinally, you can map to a categorical value as well. \nLet's categorize states into whether population is growing (at least 1%) or stable or declining.\nWe use the `if_else(condition, iftrue, iffalse)` function, which assigns the `iftrue` value if the condition is true, and `iffalse` otherwise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacts_state <- facts_state %>% \n  mutate(growth = ifelse(pop_change > 1, \"Growing\", \"Stable\"))\n\nggplot(data=facts_state) + \n  geom_point(aes(x = college, y = income, size = population, colour = growth), \n             alpha=.9)\n```\n:::\n\n\nAs you can see in these examples, ggplot tries to be smart about the mapping you ask.\nIt automatically sets the x and y ranges to the values in your data.\nIt mapped the size such that there are small and large points, but not e.g. a point so large that it would dominate the graph.\nFor the colour, for interval variables it created a colour scale, while for a categorical variable it automatically assigned a colour to each group.\n\nOf course, each of those choices can be customized, and sometimes it makes a lot of sense to do so.\nFor example, you might wish to use red for republicans and blue for democrats, if your audience is used to those colors; or you may wish to use grayscale for an old-fashioned paper publication.\nWe'll explore more options in a later tutorial, but for now let's be happy that ggplot does a lot of work for us!\n\n# Bar plots\n\nAnother frequently used plot is the bar plot. \nBy default, R bar plots assume that you want to plot a histogram, e.g. the number of occurences of each group.\nAs a very simple example, the following plots the number of states that are growing or stable in population:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_bar(aes(x = growth))\n```\n:::\n\n\nFor a more interesting plot, let's plot the votes per Republican candidate in the New Hampshire primary.\nFirst, we need to download the per-county data, summarize it per state, and filter to only get the NH results for the Republican party:\n(see the previous tutorials on [Data Transformations](R-tidy-5-transformation.md) and [Joining data](R-tidy-13a-joining.md) for more information if needed)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl_state <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/primary_results.csv\"\n\nresults_state <- read_csv(url_state) %>% \n  group_by(state, party, candidate) %>% \n  summarize(votes=sum(votes))\n\nnh_gop <- results_state %>% \n  filter(state == \"New Hampshire\" & party == \"Republican\")\nnh_gop\n```\n:::\n\n\nNow, let's make a bar plot with votes (y) per candidate (x).\nWe use `geom_col` here, which means that we provide a `y` aesthetic rather than having ggplot calculate it from the frequencies. \nEquivalently, we could have users `geom_bar(stat=\"identity\")` to create a bar plot with an 'identity' statistics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_col(aes(x=candidate, y=votes))\n```\n:::\n\n\n## Setting graph options\n\nSome options, like labels, legends, and the coordinate system are graph-wide rather than per layer. You add these options to the graph by adding extra functions to the call.\nFor example, we can use coord_flip() to swap the x and y axes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_col(aes(x=candidate, y=votes)) +\n  coord_flip()\n```\n:::\n\n\nYou can also reorder categories with the `fct_reorder` function, for example to sort by number of votes. Also, let's add some colour (just because we can!):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_bar(aes(x=fct_reorder(candidate, votes), y=votes, fill=candidate), \n           stat='identity') + \n  coord_flip()\n```\n:::\n\n\n(Note: this works because ggplot assumes all labels are `factor`s, which have an ordering;\nyou can use other functions from the `forcats` package (generally starting with `fct_`) to do other things such\nas reversing the order, manually specifying the order, etc).\n\nThis is getting somewhere, but the y-axis label is not very pretty and we don't need guides for the fill mapping. This can be remedied by more graph-level options.\nAlso, we can use a `theme` to alter the appearance of the graph, for example using the minimal theme:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_bar(aes(x=reorder(candidate, votes), y=votes, fill=candidate), \n           stat='identity') + \n  coord_flip() + \n  xlab(\"Candidate\") + \n  guides(fill=\"none\") + \n  theme_minimal()\n```\n:::\n\n\n## Grouped bar plots\n\nWe can also add groups to bar plots. \nFor example, we can set the x category to state (taking only NH and IA to keep the plot readable), and then group by candidate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngop2 <- results_state %>% \n  filter(party == \"Republican\" & (state == \"New Hampshire\" | state == \"Iowa\")) \nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate))\n```\n:::\n\n\nBy default, the groups are stacked. This can be controlled with the position parameter, which can be `dodge` (for grouped bars) or `fill` (stacking to 100%): \n(note that the position is a constant, not an aesthetic mapping, so it goes outside the `aes` argument)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate), position='dodge')\nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate), position='fill')\n```\n:::\n\n\nOf course, you can also make the grouped bars add up to 100% by computing the proportion manually,\nwhich can give you a bit more control over the process.\n\nNote that the example below pipes the preprocessing output directly into the `ggplot` command,\nthat is, it doesn't create a new temporary data set like `gop2` above.\nThis is entirely a stylistic choice, but can be useful for operations that are only intended for a single visualization. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngop2 %>% \n  group_by(state) %>% \n  mutate(vote_prop=votes/sum(votes)) %>%\n  ggplot() + \n    geom_col(aes(x=state, y=vote_prop, fill=candidate), position='dodge') + \n    ylab(\"Votes (%)\")\n```\n:::\n\n\nNote that where `group_by %>% summarize` replaces the data frame by a summarization, `group_by %>% mutate` adds a column to the existing data frame, using the grouped values for e.g. sums. See our tutorial on [Data Summarization](R-tidy-5b-groupby.md) for more details.\n\n# Line plots\n\nFinally, another frequent graph is the line graph. \nFor example, we can plot the ascendancy of Donald Trump by looking at his vote share over time. \nFirst, we combine the results per state with the primary schedule: (see the tutorial on [Joining data](R-tidy-13a-joining.md))\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dataset 1: dates for each primary\nurl2 <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/primary_schedule.csv\"\nschedule  <- read_csv(url2)\nschedule <- schedule %>% \n  mutate(date = as.Date(date, format=\"%m/%d/%y\"))\nschedule\n\n# dataset 2: vote share for trump for each state\ntrump = results_state %>% \n  group_by(state, party) %>% \n  mutate(vote_prop=votes/sum(votes)) %>% \n  filter(candidate==\"Donald Trump\")\ntrump\n\n# join the two data sets\ntrump <- left_join(trump, schedule) %>% \n  group_by(date) %>% \n  summarize(vote_prop = mean(vote_prop))\ntrump\n```\n:::\n\n\nTake a minute to inspect the code above, and try to understand what each line does! \nThe best way to do this is to inspect the output of each line, and trace back how that output is computed based on the input data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(trump) + geom_line(aes(x = date, y = vote_prop))\n```\n:::\n\n\nWe can do the same for multiple candidates as well, for example for the democratic candidates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndems <- results_state %>% \n  filter(party == \"Democrat\") %>% \n  left_join(schedule)\ndems <- dems %>% \n  group_by(date, candidate) %>% \n  summarize(votes = sum(votes)) %>% \n  mutate(vote_prop = votes / sum(votes))\nggplot(dems) + \n  geom_line(aes(x = date, y = vote_prop, colour = candidate))\n```\n:::\n\n\nBonus question: in the code for Trump, the proportion was calculated in two statements (first per state, then per date), but in this code it is calculated only per date. \nHow does that matter? Is either calculation more correct than the other?\n\n# Multiple 'faceted' plots\n\nJust to show off some of the possibilities of ggplot, let's make a plot of all republican primary outcomes on Super Tuesday (March 1st):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuper <- results_state %>% \n  left_join(schedule) %>% \n  filter(party == \"Republican\" & date == \"2016-03-01\") %>% \n  group_by(state) %>% \n  mutate(vote_prop = votes/sum(votes))\n\nggplot(super) + \n  geom_bar(aes(x = candidate, y = vote_prop), \n           stat = 'identity') + \n  facet_wrap(~state, nrow = 3) + \n  coord_flip()\n```\n:::\n\n\nNote ~facet_wrap~ wraps around a single facet. You can also use ~facet_grid() to specify separate variables for rows and columns\n\n# Themes\n\nCustomization of things like background colour, grid colour etc. is handled by themes. \n`ggplot` has two built-in themes: `theme_grey` (default) and `theme_bw` (for a more minimal theme with white background). \nThe package ggthemes has some more themes, including an 'economist' theme (based on the newspaper).\nTo use a theme, simply add it to the plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggthemes)\nggplot(trump) + \n  geom_line(aes(x = date, y = vote_prop)) + \n  theme_economist()\n```\n:::\n\n\nYou can also modify any of the theming elements yourself (check the help for `theme()` for more information):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(trump) + \n  geom_line(aes(x = date, y = vote_prop)) + \n  theme_economist() +\n  theme(panel.grid.major.y = element_line(colour=\"lightblue\"))\n```\n:::\n\n\nSome links for learning more about themes:\n\n + https://ggplot2.tidyverse.org/reference/theme.html\n + https://www.datanovia.com/en/blog/ggplot-themes-gallery\n + http://rstudio-pubs-static.s3.amazonaws.com/284329_c7e660636fec4a42a09eed968dc47f32.html\n\n# Plotting maps\n\nGeographic information can be plotted in `ggplot` much like scatter plots,\nsimply using longitude and lattitude as x and y. \nOften, we want to plot data on an actual map of (part of) the world,\nfor example to plot locations of tweets or colour a map with information per country or state.\n\nIn `ggplot` this is accomplished by plotting the shapes of the countries. The package includes shape\ndata for the US, the world, and some countries like France, but unfortunately not EU or Germany. The maps originate from the `maps` package, so you can check their documentation to see what countries are included. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nstates <- map_data('state')\nhead(states)\n```\n:::\n\n\nThis basically tells ggplot what lines to draw to form a state. If a state is not contiguous it will contain subregions resulting in multiple polygons.\n\nWe can immediately plot this data, using the `geom_polygon` to plot shapes. We specify x and y as longitude and lattitude, fill by state, and make the state borders white. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = states) + \n  geom_polygon(aes(x = long, y = lat, fill = region, group = group), \n               color = \"white\") + \n  coord_fixed(1.3) + \n  guides(fill=\"none\")  \n```\n:::\n\n\nNote: the last line fixes the aspect ratio to 1.3 and prevents a per-state legend (guide) from being plotted.\n\n\nThis example coloured the states as a non-informative nominal variable. We can also colour by our own data, for example by percentage white ethnicity:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates <- facts_state %>% \n  mutate(region=tolower(area_name)) %>% \n  select(region, white) %>% \n  inner_join(states)\n\nggplot(data = states) + \n  geom_polygon(aes(x = long, y = lat, fill = white, group = group), color = \"white\") + \n  coord_fixed(1.3) + theme_void() + \n  ggtitle(\"Percentage white population per state\") \n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}