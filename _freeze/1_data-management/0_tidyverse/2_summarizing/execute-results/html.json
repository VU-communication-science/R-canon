{
  "hash": "88dc750bde733c5d927891e380e34027",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Summarizing\n---\n\n\n\n\n# Data Summarization\n\nThe functions used in the earlier part on data preparation worked on individual rows.\nSometimes, you need to compute properties of groups of rows (cases).\nThis is called aggregation (or summarization) and in tidyverse uses the `group_by` function\nfollowed by either `summarize` or `mutate`. \n\n# Simple data summarization\n\nFirst, let's fire up tidyverse and load the gun polls data used in the earlier example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nurl <- \"https://raw.githubusercontent.com/fivethirtyeight/data/master/poll-quiz-guns/guns-polls.csv\"\nd <- read_csv(url) %>% \n  select(-URL) %>% \n  rename(Rep = `Republican Support`, Dem = `Democratic Support`)\nd\n```\n:::\n\n\n## Grouping rows\n\nNow, we can use the group_by function to group by, for example, pollster:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question)\n```\n:::\n\n\nAs you can see, the data itself didn't actually change yet, it merely recorded (at the top) that we are now grouping by Question,\nand that there are 8 groups (different questions) in total. \n\n## Summarizing\n\nTo summarize, you follow the group_by with a call to `summarize`. Summarize has a syntax that is similar to mutate: `summarize(column = calculation, ...)`.\nThe crucial difference, however, is that you always need to use a function in the calculation, and that function needs to compute a single summary value given a vector of values.\nVery common summarization functions are sum, mean, and sd (standard deviation). \n\nFor example, the following computes the average support per question\n(and sorts by descending support):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>%                    # group by \"Questions\"\n  summarize(Support = mean(Support)) %>%    # average \"Support\" per group\n  arrange(-Support)                         # sort based on \"Support\"\n```\n:::\n\n\nAs you can see, summarize drastically changes the shape of the data. There are now rows equal to the number of groups (8), and the only columns left are the grouping variables and the summarized values. \n\nYou can also compute summaries of multiple values, and even do ad hoc calculations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>% \n  summarize(Dem = mean(Dem), \n            Rep = mean(Rep), \n            diff = mean(Dem-Rep)) %>% \n  arrange(-diff)\n```\n:::\n\n\nSo, Democrats are more in favor of all proposed gun laws except arming teachers.\n\nYou can also compute multiple summaries of a single value. \nAnother useful function is `n()` (without arguments), which simply counts the values in each group.\nFor example, the following gives the count, mean, and standard deviation of the support:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>% \n  summarize(n = n(),\n            mean = mean(Support), \n            sd = sd(Support))\n```\n:::\n\n\nNote: As you can see, one of the values has a missing value (NA) for standard deviation. Why?\n\n## Using mutate with group_by\n\nThe examples above all reduce the number of cases to the number of groups.\nAnother option is to use mutate after a group_by, which allows you to add summary values to the rows themselves. \n\nFor example, suppose we wish to see whether a certain poll has a different prediction from the average polling of that question.\nWe can group_by question and then use mutate to calculate the average support:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d %>% \n  group_by(Question) %>%\n  mutate(avg_support = mean(Support), \n         diff = Support - avg_support)\nd2\n```\n:::\n\n\nAs you can see, where summarize reduces the rows and columns to the groups and summaries,\nmutate adds a new column which is identical for all rows within a group. \n\n## Ungrouping\n\nFinally, you can use `ungroup` to get rid of any groupings. \n\nFor example, the data produced by the example above is still grouped by Question as mutate does not remove grouping information.\nSo, if we want to compute the overall standard deviation of the difference we could ungroup and then summarize:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  ungroup() %>% \n  summarize(diff = sd(diff))\n```\n:::\n\n\n(of course, running `sd(d2$diff))` would yield the same result.)\n\nIf you run the same command without the ungroup, what would the result be? Why?\n\n# Multiple grouping variables\n\nThe above examples all used a single grouping variable, but you can also group by multiple columns.\nFor example, I could compute average support per question and per population:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question, Population) %>% \n  summarize(Support = mean(Support))\n```\n:::\n\n\nThis results in a data set with one row per unique group, i.e. combination of Question and Population, and with separate columns for each grouping column and the summary values. \n\nAs you can see from the example above, the resulting data set is still grouped by, but only by `Question`. \nKeeping the groups intact after summarization would not be useful, as you would never want to compute a summary of the same groups:\neach of the old groups is now a single row. \nThus, while mutate keeps the grouping information intact, *summarize drops the outermost grouping column*, in this case Population.\n\nThis allows you to compute the the (macro-)average support per question: (i.e. the mean of the summaries per population)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question, Population) %>% \n  summarize(Support = mean(Support)) %>% \n  mutate(avg_support = mean(Support))\n```\n:::\n\n\nCan you find a way to add the micro-average as well (i.e. the mean of the individual polls)?\n\n# Missing values\n\nSummary functions in R by default return `NA` if any of the values to be summarized are `NA`:\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(3,4,NA,6))\n```\n:::\n\n\nAs a result, if you summarize over rows that contain a missing value, it will set the summary value to NA.\nLet's first use `ifelse` to introduce a NA value: we set Support to NA for any CBS News polls:\n\nNote: Ifelse takes 3 values: `ifelse(test, value-if-true, value-if-false)`, which will set each row according to the test.\nIn this case, we test whether Pollster equals CBS, and if true, set support to NA, otherwise set support to support (i.e. keep it unchanged)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d %>% \n  mutate(Support = ifelse(Pollster == \"CBS News\", NA, Support))\n```\n:::\n\n\nNow, if we take the mean support per question it will return NA for any questions on which CBS was part of the set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  group_by(Question) %>% \n  summarize(Support = mean(Support))\n```\n:::\n\n\nWhile this is a very 'correct' way to treat missing values, in many cases we simply want to ignore this. So, we add `na.rm=T` to the mean function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  group_by(Question) %>% \n  summarize(Support = mean(Support, na.rm = T))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}