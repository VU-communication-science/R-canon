{
  "hash": "bfea3c2efa06b4c7fe7dd16492478747",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Joining data\n---\n\n\n\n\n\n# Joining data\n\nIn many cases, you need to combine data from multiple data sources. \nFor example, you can combine a sentiment analysis of tweets with metadata about the tweets;\nor data on election results with data about the candidates ideological positions or details on the races. \n\nThis tutorial will teach you the `inner_join` and other `_join` commands used to combine two data sets on shared columns. \nSee [R4DS Chapter 13: Relational Data](http://r4ds.had.co.nz/relational-data.html) for more information and examples. \n\n## Data\n\nFor this tutorial, we will look at data describing the US presidential primaries.\nThese data can be downloaded from the [Houston Data Visualisation github page](https://github.com/houstondatavis/data-jam-august-2016), who in turn got it from [Kaggle](https://www.kaggle.com/benhamner/2016-us-election). \n\nIn the CSV folder on the github, you can find (among others)\n\t\t\n- `primary_results.csv` Number of votes in the primary per county per candidate\n- `primary_schedule.csv` Dates of each primary per state and per party\n- `county_facts.csv` Information about the counties and states, including population, ethnicity, age, etc. \n\nFor many research questions, we need to be able to combine the data from these files. \nFor example, we might want to know if Clinton did better in counties or states with more women (needing results and facts), or how Trump's performance evolved over time (requiring results and calendar).\n\n## Downloading and preparing the data\n\nBefore we start, let's download the three data files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ncsv_folder_url <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv\"\nresults <- read_csv(paste(csv_folder_url, \"primary_results.csv\", sep = \"/\"))\nfacts <- read_csv(paste(csv_folder_url, \"county_facts.csv\", sep = \"/\"))\nschedule  <- read_csv(paste(csv_folder_url, \"primary_schedule.csv\", sep = \"/\"))\n```\n:::\n\n\nNote: I use `paste` to join the base url with the filenames, using a `/` as a `sep`arator.\n\nHave a look at all three data sets. Before we proceed, there are some things we want to do. \nFirst, the `facts` data frame is really large, with 54 columns. Let's select a couple interesting ones to work with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacts_subset <- facts %>% \n  select(area_name, \n         population = Pop_2014_count, \n         pop_change = Pop_change_pct, \n         over65 = Age_over_65_pct, \n         female = Sex_female_pct, \n         white = Race_white_pct, \n         college = Pop_college_grad_pct, \n         income = Income_per_capita)\n```\n:::\n\n\nNext, the schedule dates are now a character (textual) field rather than date, so let's fix that\nusing the `as.Date` function, specifying the dates to be formatted as month/day/year:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschedule <- schedule %>% \n  mutate(date = as.Date(date, format=\"%m/%d/%y\"))\n```\n:::\n\n\nLast, let's create a data set with per-state (rather than per-country) election results using `group_by` and `summarize`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_state <- results %>% \n  group_by(state, party, candidate) %>% \n  summarize(votes = sum(votes))\nresults_state\n```\n:::\n\n\nNote: see [R-tidy-5-transformations](R-tidy-5-transformation.md) if you are unsure about the transformations above!\n\n# Simplest case: `inner_join`\n\nThe basic command for joining data in R is the `inner join`. It takes two data frames and joins it on any variable that occurs in both. \nIt results in a new data frame with the information in both frames joined together.\nFor example, this adds the dates to all primary results (per state)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(results_state, schedule)\n```\n:::\n\n\n# Specifying columns\n\nBy default, joining is performed with all shared columns as joining *keys*.\nIf this is not correct, you can specify the joining key with the `by=` option.\nA common use case is if the variable names are not the same, for example the state in the `facts` data is coded as `area_name`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(results_state, facts_subset, by = c(\"state\" = \"area_name\"))\n```\n:::\n\n\n# Left and right joins\n\nAs seen above, `inner_join` keeps only rows that occur in both data sets: \nthe county-level facts are (silently) dropped because their names don't occur in the state results.\n\nSometimes this is undesirable. For example, suppose we have data on candidate age, but not on all candidates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- tibble(candidate = c(\"Hillary Clinton\", \"Bernie Sanders\", \"Donald Trump\"), \n              age = c(70, 77, 72))\nage\n```\n:::\n\n\nNow, if we would do an `inner_join` with the election results it would drop all other candidates (since they do not occur in the age dataset):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(results_state, age)\n```\n:::\n\n\nYou can prevent this from occurring by using `left_join`, which always keeps all rows in the first dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(results_state, age)\n```\n:::\n\n\nAs you can see, Ben Carson and others are still in the data, with missing values (NA) in their age column.\nLeft join keeps all rows in the first data sets, but drops rows in the second data set that don't occur in the first. \nRight join does the opposite, keeping all rows in the second data set but potentially dropping rows in the first.\nFinally, `full_join` keeps all rows that occur in either data set. \n\n\n",
    "supporting": [
      "5_joining_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}