{
  "hash": "a8174d819a218d2c4802d19eb2f7d29d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Filter and Arrange rows\"\nsubtitle: Filter rows and arrange them in a specific order\norder: 2\n---\n\n\n\n\n\nFor the examples in this tutorial we'll use the `iris` dataset, like we [explained here](./import-and-view.qmd#iris).\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nd <- as_tibble(iris)\n```\n:::\n\n\n\n\n\n\n# Subsetting rows with filter() {#filter} \n\nThe `filter` function can be used to select a subset of rows. \nFor example, the following code selects only the rows where the `Species` column is equal to `setosa`.\nThe first argument of the `filter` function is the tibble you want to filter.\nThe second argument is the condition that should be met for a row to be included in the result.\nHere we use the `==` operator to say that the value in the `Species` column should be equal to `setosa`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(d, Species == 'setosa')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 40 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nNote that we now get 50 out of the 150 rows in the `iris` dataset.\n\nWe can use other common operators as well, such as `>`, `<`, `>=`, `<=`, and `!=` (not equal).\nAnd we can also combine multiple conditions with the `&` (and) and `|` (or) operators. \n\nFor example, here we select all rows where the `Species` is `setosa` and the `Sepal.Length` is greater than 5.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(d, Species == 'setosa' & Sepal.Length > 5)\n```\n:::\n\n\n\n\n\nA less common operator that is usefull to know about is `%in%`, which is used to check if a value is in a list of values.\nFor example, to select all rows where the `Species` is either `setosa` or `versicolor`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(d, Species %in% c('setosa', 'versicolor'))\n```\n:::\n\n\n\n\n\n::: {.callout-note title=\"A deeper understanding of the filter condition\" collapse=\"true\"}\n\nBased on the examples given you probably already have a good enough understanding of how the `filter` function works to use it in your own code.\nIn this optional information block we'll go a bit deeper into how the filter condition works, and what operators you can use.\n\n## The condition is a logical expression\n\nThe condition in `filter` can be any **logical expression**.\nA logical expression is simply a statement that is either `TRUE` or `FALSE`.\nWhen we use a logical expression in the `filter` function, we are asking R to evaluate this expression for each row in the tibble. \nEach row for which the expression evaluates to `TRUE` is then included in the subset.\n\nIf you know a bit about how logical expressions work, you will have great control over what rows are included in your subset.\nHere is an overview of the most important operators for logical expressions.\n\n### Comparison operators\n\nComparison operators are used to compare two values.\n\n- `==`   equal to\n- `!=`   not equal to\n- `>`    greater than\n- `>=`   greater than or equal to\n- `<`    less than\n- `<=`   less than or equal to\n- `%in%` is in a list of values (second value must be a list or vector) \n\nExample: \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 > 1    # TRUE:  5 is greater than 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n5 < 1    # FALSE: 5 is less than 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"setosa\" %in% c(\"setosa\", \"versicolor\")  # TRUE: \"setosa\" is in the list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Logical operators\n\nLogical operators are used to combine multiple conditions.\n\n- `&` and\n- `|` or\n- `!` not\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 > 1 | 5 < 1   # TRUE: 5 is greater than 1 OR 5 is less than 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n5 > 1 & 5 < 1   # FALSE: 5 is greater than 1 AND 5 is less than 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!5 < 1          # TRUE: it is not the case that 5 is smaller than 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Parentheses\n\nFor complex conditions, you can use parentheses to group conditions, similar to how you would in a mathematical expression.\nSay you want to select big flowers, but you want to take into account that some species are generally smaller.\nSo the minimum Sepal.Length for `setosa` should be 5, but for `versicolor` it should be 6.\nYou could then write the following condition:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(d, (Species == 'setosa' & Sepal.Length > 5) | \n          (Species == 'versicolor' & Sepal.Length > 6)\n      )\n```\n:::\n\n\n\n\n:::\n\n# Sorting rows with arrange() {#arrange}\n\nThe `arrange` function can be used to sort the rows of a tibble.\nFor example, if we want to sort the `iris` dataset by the `Sepal.Length` column:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(d, Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          4.3         3            1.1         0.1 setosa \n 2          4.4         2.9          1.4         0.2 setosa \n 3          4.4         3            1.3         0.2 setosa \n 4          4.4         3.2          1.3         0.2 setosa \n 5          4.5         2.3          1.3         0.3 setosa \n 6          4.6         3.1          1.5         0.2 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          4.6         3.6          1           0.2 setosa \n 9          4.6         3.2          1.4         0.2 setosa \n10          4.7         3.2          1.3         0.2 setosa \n# ℹ 140 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nBy default, the rows are sorted in ascending order.\nIf you want to sort in descending order, you can put a minus in front of the variable name.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(d, -Sepal.Length)\n```\n:::\n\n\n\n\n\nIf you want to sort on multiple columns, you can simply add them to the `arrange` function.\nFor example, to sort by `Species` and then by `Sepal.Length`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(d, Species, Sepal.Length)\n```\n:::",
    "supporting": [
      "filter-and-arrange-rows_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}