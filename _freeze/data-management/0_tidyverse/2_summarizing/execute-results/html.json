{
  "hash": "bd4abe75a88ad2b4360a6bce0b39cac3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Summarizing\n---\n\n\n\n\n\n# Data Summarization\n\nThe functions used in the earlier part on data preparation worked on individual rows.\nSometimes, you need to compute properties of groups of rows (cases).\nThis is called aggregation (or summarization) and in tidyverse uses the `group_by` function\nfollowed by either `summarize` or `mutate`. \n\n# Simple data summarization\n\nFirst, let's fire up tidyverse and load the gun polls data used in the earlier example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nurl <- \"https://raw.githubusercontent.com/fivethirtyeight/data/master/poll-quiz-guns/guns-polls.csv\"\nd <- read_csv(url) %>% \n  select(-URL) %>% \n  rename(Rep = `Republican Support`, Dem = `Democratic Support`)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 57 × 8\n   Question     Start   End     Pollster          Population Support   Rep   Dem\n   <chr>        <chr>   <chr>   <chr>             <chr>        <dbl> <dbl> <dbl>\n 1 age-21       2/20/18 2/23/18 CNN/SSRS          Registere…      72    61    86\n 2 age-21       2/27/18 2/28/18 NPR/Ipsos         Adults          82    72    92\n 3 age-21       3/1/18  3/4/18  Rasmussen         Adults          67    59    76\n 4 age-21       2/22/18 2/26/18 Harris Interacti… Registere…      84    77    92\n 5 age-21       3/3/18  3/5/18  Quinnipiac        Registere…      78    63    93\n 6 age-21       3/4/18  3/6/18  YouGov            Registere…      72    65    80\n 7 age-21       3/1/18  3/5/18  Morning Consult   Registere…      76    72    86\n 8 arm-teachers 2/23/18 2/25/18 YouGov/Huffpost   Registere…      41    69    20\n 9 arm-teachers 2/20/18 2/23/18 CBS News          Adults          44    68    20\n10 arm-teachers 2/27/18 2/28/18 Rasmussen         Adults          43    71    24\n# ℹ 47 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## Grouping rows\n\nNow, we can use the group_by function to group by, for example, pollster:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 57 × 8\n# Groups:   Question [8]\n   Question     Start   End     Pollster          Population Support   Rep   Dem\n   <chr>        <chr>   <chr>   <chr>             <chr>        <dbl> <dbl> <dbl>\n 1 age-21       2/20/18 2/23/18 CNN/SSRS          Registere…      72    61    86\n 2 age-21       2/27/18 2/28/18 NPR/Ipsos         Adults          82    72    92\n 3 age-21       3/1/18  3/4/18  Rasmussen         Adults          67    59    76\n 4 age-21       2/22/18 2/26/18 Harris Interacti… Registere…      84    77    92\n 5 age-21       3/3/18  3/5/18  Quinnipiac        Registere…      78    63    93\n 6 age-21       3/4/18  3/6/18  YouGov            Registere…      72    65    80\n 7 age-21       3/1/18  3/5/18  Morning Consult   Registere…      76    72    86\n 8 arm-teachers 2/23/18 2/25/18 YouGov/Huffpost   Registere…      41    69    20\n 9 arm-teachers 2/20/18 2/23/18 CBS News          Adults          44    68    20\n10 arm-teachers 2/27/18 2/28/18 Rasmussen         Adults          43    71    24\n# ℹ 47 more rows\n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, the data itself didn't actually change yet, it merely recorded (at the top) that we are now grouping by Question,\nand that there are 8 groups (different questions) in total. \n\n## Summarizing\n\nTo summarize, you follow the group_by with a call to `summarize`. Summarize has a syntax that is similar to mutate: `summarize(column = calculation, ...)`.\nThe crucial difference, however, is that you always need to use a function in the calculation, and that function needs to compute a single summary value given a vector of values.\nVery common summarization functions are sum, mean, and sd (standard deviation). \n\nFor example, the following computes the average support per question\n(and sorts by descending support):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>%                    # group by \"Questions\"\n  summarize(Support = mean(Support)) %>%    # average \"Support\" per group\n  arrange(-Support)                         # sort based on \"Support\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n  Question                    Support\n  <chr>                         <dbl>\n1 background-checks              87.4\n2 mental-health-own-gun          85.8\n3 age-21                         75.9\n4 ban-high-capacity-magazines    67.3\n5 stricter-gun-laws              66.5\n6 ban-assault-weapons            61.8\n7 arm-teachers                   42  \n8 repeal-2nd-amendment           10  \n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, summarize drastically changes the shape of the data. There are now rows equal to the number of groups (8), and the only columns left are the grouping variables and the summarized values. \n\nYou can also compute summaries of multiple values, and even do ad hoc calculations:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>% \n  summarize(Dem = mean(Dem), \n            Rep = mean(Rep), \n            diff = mean(Dem-Rep)) %>% \n  arrange(-diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  Question                      Dem   Rep    diff\n  <chr>                       <dbl> <dbl>   <dbl>\n1 stricter-gun-laws            86.9  46.4  40.5  \n2 ban-assault-weapons          80.7  42.6  38.1  \n3 ban-high-capacity-magazines  83.9  52.7  31.1  \n4 age-21                       86.4  67    19.4  \n5 repeal-2nd-amendment         15     5    10    \n6 background-checks            91.9  83.6   8.29 \n7 mental-health-own-gun        87.5  86.7   0.833\n8 arm-teachers                 17.2  72.2 -55    \n```\n\n\n:::\n:::\n\n\n\n\nSo, Democrats are more in favor of all proposed gun laws except arming teachers.\n\nYou can also compute multiple summaries of a single value. \nAnother useful function is `n()` (without arguments), which simply counts the values in each group.\nFor example, the following gives the count, mean, and standard deviation of the support:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question) %>% \n  summarize(n = n(),\n            mean = mean(Support), \n            sd = sd(Support))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  Question                        n  mean    sd\n  <chr>                       <int> <dbl> <dbl>\n1 age-21                          7  75.9  6.01\n2 arm-teachers                    6  42    1.55\n3 background-checks               7  87.4  7.32\n4 ban-assault-weapons            12  61.8  6.44\n5 ban-high-capacity-magazines     7  67.3  3.86\n6 mental-health-own-gun           6  85.8  5.46\n7 repeal-2nd-amendment            1  10   NA   \n8 stricter-gun-laws              11  66.5  5.15\n```\n\n\n:::\n:::\n\n\n\n\nNote: As you can see, one of the values has a missing value (NA) for standard deviation. Why?\n\n## Using mutate with group_by\n\nThe examples above all reduce the number of cases to the number of groups.\nAnother option is to use mutate after a group_by, which allows you to add summary values to the rows themselves. \n\nFor example, suppose we wish to see whether a certain poll has a different prediction from the average polling of that question.\nWe can group_by question and then use mutate to calculate the average support:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d %>% \n  group_by(Question) %>%\n  mutate(avg_support = mean(Support), \n         diff = Support - avg_support)\nd2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 57 × 10\n# Groups:   Question [8]\n   Question     Start  End   Pollster Population Support   Rep   Dem avg_support\n   <chr>        <chr>  <chr> <chr>    <chr>        <dbl> <dbl> <dbl>       <dbl>\n 1 age-21       2/20/… 2/23… CNN/SSRS Registere…      72    61    86        75.9\n 2 age-21       2/27/… 2/28… NPR/Ips… Adults          82    72    92        75.9\n 3 age-21       3/1/18 3/4/… Rasmuss… Adults          67    59    76        75.9\n 4 age-21       2/22/… 2/26… Harris … Registere…      84    77    92        75.9\n 5 age-21       3/3/18 3/5/… Quinnip… Registere…      78    63    93        75.9\n 6 age-21       3/4/18 3/6/… YouGov   Registere…      72    65    80        75.9\n 7 age-21       3/1/18 3/5/… Morning… Registere…      76    72    86        75.9\n 8 arm-teachers 2/23/… 2/25… YouGov/… Registere…      41    69    20        42  \n 9 arm-teachers 2/20/… 2/23… CBS News Adults          44    68    20        42  \n10 arm-teachers 2/27/… 2/28… Rasmuss… Adults          43    71    24        42  \n# ℹ 47 more rows\n# ℹ 1 more variable: diff <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, where summarize reduces the rows and columns to the groups and summaries,\nmutate adds a new column which is identical for all rows within a group. \n\n## Ungrouping\n\nFinally, you can use `ungroup` to get rid of any groupings. \n\nFor example, the data produced by the example above is still grouped by Question as mutate does not remove grouping information.\nSo, if we want to compute the overall standard deviation of the difference we could ungroup and then summarize:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  ungroup() %>% \n  summarize(diff = sd(diff))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n   diff\n  <dbl>\n1  5.19\n```\n\n\n:::\n:::\n\n\n\n\n(of course, running `sd(d2$diff))` would yield the same result.)\n\nIf you run the same command without the ungroup, what would the result be? Why?\n\n# Multiple grouping variables\n\nThe above examples all used a single grouping variable, but you can also group by multiple columns.\nFor example, I could compute average support per question and per population:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question, Population) %>% \n  summarize(Support = mean(Support))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'Question'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 3\n# Groups:   Question [8]\n   Question                    Population        Support\n   <chr>                       <chr>               <dbl>\n 1 age-21                      Adults               74.5\n 2 age-21                      Registered Voters    76.4\n 3 arm-teachers                Adults               42.7\n 4 arm-teachers                Registered Voters    41.3\n 5 background-checks           Adults               84.5\n 6 background-checks           Registered Voters    88.6\n 7 ban-assault-weapons         Adults               62.5\n 8 ban-assault-weapons         Registered Voters    61.6\n 9 ban-high-capacity-magazines Adults               73  \n10 ban-high-capacity-magazines Registered Voters    66.3\n11 mental-health-own-gun       Adults               92  \n12 mental-health-own-gun       Registered Voters    84.6\n13 repeal-2nd-amendment        Registered Voters    10  \n14 stricter-gun-laws           Adults               70  \n15 stricter-gun-laws           Registered Voters    65.7\n```\n\n\n:::\n:::\n\n\n\n\nThis results in a data set with one row per unique group, i.e. combination of Question and Population, and with separate columns for each grouping column and the summary values. \n\nAs you can see from the example above, the resulting data set is still grouped by, but only by `Question`. \nKeeping the groups intact after summarization would not be useful, as you would never want to compute a summary of the same groups:\neach of the old groups is now a single row. \nThus, while mutate keeps the grouping information intact, *summarize drops the outermost grouping column*, in this case Population.\n\nThis allows you to compute the the (macro-)average support per question: (i.e. the mean of the summaries per population)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  group_by(Question, Population) %>% \n  summarize(Support = mean(Support)) %>% \n  mutate(avg_support = mean(Support))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'Question'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 4\n# Groups:   Question [8]\n   Question                    Population        Support avg_support\n   <chr>                       <chr>               <dbl>       <dbl>\n 1 age-21                      Adults               74.5        75.4\n 2 age-21                      Registered Voters    76.4        75.4\n 3 arm-teachers                Adults               42.7        42  \n 4 arm-teachers                Registered Voters    41.3        42  \n 5 background-checks           Adults               84.5        86.6\n 6 background-checks           Registered Voters    88.6        86.6\n 7 ban-assault-weapons         Adults               62.5        62.0\n 8 ban-assault-weapons         Registered Voters    61.6        62.0\n 9 ban-high-capacity-magazines Adults               73          69.7\n10 ban-high-capacity-magazines Registered Voters    66.3        69.7\n11 mental-health-own-gun       Adults               92          88.3\n12 mental-health-own-gun       Registered Voters    84.6        88.3\n13 repeal-2nd-amendment        Registered Voters    10          10  \n14 stricter-gun-laws           Adults               70          67.8\n15 stricter-gun-laws           Registered Voters    65.7        67.8\n```\n\n\n:::\n:::\n\n\n\n\nCan you find a way to add the micro-average as well (i.e. the mean of the individual polls)?\n\n# Missing values\n\nSummary functions in R by default return `NA` if any of the values to be summarized are `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(3,4,NA,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nAs a result, if you summarize over rows that contain a missing value, it will set the summary value to NA.\nLet's first use `ifelse` to introduce a NA value: we set Support to NA for any CBS News polls:\n\nNote: Ifelse takes 3 values: `ifelse(test, value-if-true, value-if-false)`, which will set each row according to the test.\nIn this case, we test whether Pollster equals CBS, and if true, set support to NA, otherwise set support to support (i.e. keep it unchanged)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d %>% \n  mutate(Support = ifelse(Pollster == \"CBS News\", NA, Support))\n```\n:::\n\n\n\n\nNow, if we take the mean support per question it will return NA for any questions on which CBS was part of the set:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  group_by(Question) %>% \n  summarize(Support = mean(Support))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n  Question                    Support\n  <chr>                         <dbl>\n1 age-21                         75.9\n2 arm-teachers                   NA  \n3 background-checks              NA  \n4 ban-assault-weapons            NA  \n5 ban-high-capacity-magazines    67.3\n6 mental-health-own-gun          85.8\n7 repeal-2nd-amendment           10  \n8 stricter-gun-laws              NA  \n```\n\n\n:::\n:::\n\n\n\n\nWhile this is a very 'correct' way to treat missing values, in many cases we simply want to ignore this. So, we add `na.rm=T` to the mean function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 %>% \n  group_by(Question) %>% \n  summarize(Support = mean(Support, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n  Question                    Support\n  <chr>                         <dbl>\n1 age-21                         75.9\n2 arm-teachers                   41.6\n3 background-checks              89.5\n4 ban-assault-weapons            62.5\n5 ban-high-capacity-magazines    67.3\n6 mental-health-own-gun          85.8\n7 repeal-2nd-amendment           10  \n8 stricter-gun-laws              66.6\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}