{
  "hash": "f7b2c3fff4a7b5db617fde401ceb0d56",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualization basics\"\n---\n\n\n\n\n\nThis tutorial teaches the basics of data visualization using the `ggplot2` package (included in `tidyverse`). \nFor more information, see [R4DS Chapter 3: Da`ta Visualization](http://r4ds.had.co.nz/data-visualisation.html) and  [R4DS Chapter 7: Exploratory Data Analysis](http://r4ds.had.co.nz/exploratory-data-analysis.html).\n\nFor *many* cool visualization examples using `gplot2` (with R code included!) see the [R Graph Gallery](https://www.r-graph-gallery.com/portfolio/ggplot2-package/).\nFor inspiration (but unfortunately no R code), there is also a [538 blog post on data visualization from 2016](https://fivethirtyeight.com/features/the-52-best-and-weirdest-charts-we-made-in-2016/).\nFinally, see the article on '[the grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html)' published by Hadley Wickham for more insight into the ideas behind ggplot.\n\n# A Basic ggplot plot\n\nSuppose that we want to see the relation between college education and household income, both included in the `county facts` subset published by  [Houston Data Visualisation github page](https://github.com/houstondatavis/data-jam-august-2016).\nSince this data set contains a large amount of columns, we keep only a subset of columns for now:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nurl <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/county_facts.csv\"\nfacts <- read_csv(url) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 3195 Columns: 54\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): area_name, state_abbreviation\ndbl (52): fips, Pop_2014_count, Pop_2010_base_count, Pop_change_pct, Pop_201...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nfacts_subset <- facts %>% \n  select(fips, area_name, state_abbreviation, \n         population = Pop_2014_count, \n         pop_change = Pop_change_pct,\n         over65 = Age_over_65_pct, \n         female = Sex_female_pct,\n         white = Race_white_pct,\n         college = Pop_college_grad_pct, \n         income = Income_per_capita)\nfacts_state <- facts_subset %>% \n  filter(is.na(state_abbreviation) & fips != 0) %>% \n  select(-state_abbreviation)\nfacts_state\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 × 9\n    fips area_name      population pop_change over65 female white college income\n   <dbl> <chr>               <dbl>      <dbl>  <dbl>  <dbl> <dbl>   <dbl>  <dbl>\n 1  1000 Alabama           4849377        1.4   15.3   51.5  69.7    22.6  23680\n 2  2000 Alaska             736732        3.7    9.4   47.4  66.9    27.5  32651\n 3  4000 Arizona           6731484        5.3   15.9   50.3  83.7    26.9  25358\n 4  5000 Arkansas          2966369        1.7   15.7   50.9  79.7    20.1  22170\n 5  6000 California       38802500        4.2   12.9   50.3  73.2    30.7  29527\n 6  8000 Colorado          5355866        6.5   12.7   49.8  87.7    37    31109\n 7  9000 Connecticut       3596677        0.6   15.5   51.2  81.2    36.5  37892\n 8 10000 Delaware           935614        4.2   16.4   51.6  70.8    28.9  29819\n 9 11000 District Of C…     658893        9.5   11.3   52.6  43.6    52.4  45290\n10 12000 Florida          19893297        5.8   19.1   51.1  77.8    26.4  26236\n# ℹ 41 more rows\n```\n\n\n:::\n:::\n\n\n\n\nNow, let's make a *scatter plot* with percentage college-educated on the x-axis and median income on the y-axis. First, we can used the function `ggplot` to create an empty canvas tied to the dataset `facts_state` and tell the function which variables to use:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state,        # which data set?\n       aes(x=college, y=income))  # which variables as aesthetics?\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\nNext, we need to tell ggplot what to plot. In this case, we want to produce a scatterplot. The function `geom_point` adds a layer of information to the canvas. In the language of ggplot, each layer has a *geometrical representation*, in this case \"points\". In this case, the \"x\" and \"y\" are mapped to the college and income columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state,\n       mapping = aes(x = college, y = income)) + \n  geom_point()   # adding the geometrical representation\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nSo called *aesthetic mappings*, which map the visual elements of the geometry to columns of the data, can also be included as argument in the `geom`. This can be handy when several `geoms` are plotted and different aesthetics are used. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# same plot as above\nggplot(data = facts_state) + \n  geom_point(mapping = aes(x = college, y = income)) \n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\nThe result is a plot where each point here represents a state, and we see a clear correlation between education level and income. There is one clear outlier on the top-right. Can you guess which state that is?\n\nDue to the layer logic of ggplot, we can add more `geoms` to the plot (e.g., a regression line). \nRemember that if we provide aesthetics within the `ggplot`-function, these are passed to all `geoms`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loess curve\nggplot(data = facts_state, \n       mapping = aes(x = college, y = income)) + \n  geom_point() +\n  geom_smooth() \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Linear regression line\nggplot(data = facts_state, \n       mapping = aes(x = college, y = income)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n\n\n\n## Important note on ggplot command syntax\n\nFor the plot to work, R needs to execute the whole ggplot call and all layers as a single statement.\nPractically, that means that if you combine a plot over multiple lines, the plus sign needs to be at the end of the line, so R knows more is coming. The general syntax is always:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))\n```\n:::\n\n\n\n\n\nSo, the following is good:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(mapping = aes(x = college, y = income))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nBut this is not:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) \n  + geom_point(mapping = aes(x = college, y = income))\n```\n:::\n\n\n\n\nAlso note that the data and mapping arguments are the first arguments the functions expect, so you can also leave them out:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(facts_state) + \n  geom_point(aes(x = college, y = income))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n## Other aesthetics  \n\nTo find out which visual elements can be used in a layer, use e.g. `?geom_point`. According to the help file, we can (among others) set the colour, alpha (transparency), and size of points.\nLet's first set the size of points to the (log) population of each state, creating a bubble plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x = college, y = income, size = population))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\nSince it is difficult to see overlapping points, let's make all points somewhat transparent. \nNote: Since we want to set the alpha of all points to a single value, this is not a mapping (as it is not mapped to a column from the data frame), but a constant.\nThese are set outside the mapping argument:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x = college, y = income, size = population), \n             alpha = .5, \n             colour = \"red\")\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nInstead of setting colour to a constant value, we can also let it vary with the data. For example, we can colour the states by percentage of population that is identified as 'white':\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_point(aes(x=college, y=income, size=population, colour=white), \n             alpha=.9)\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\nFinally, you can map to a categorical value as well. \nLet's categorize states into whether population is growing (at least 1%) or stable or declining.\nWe use the `if_else(condition, iftrue, iffalse)` function, which assigns the `iftrue` value if the condition is true, and `iffalse` otherwise:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacts_state <- facts_state %>% \n  mutate(growth = ifelse(pop_change > 1, \"Growing\", \"Stable\"))\n\nggplot(data=facts_state) + \n  geom_point(aes(x = college, y = income, size = population, colour = growth), \n             alpha=.9)\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\nAs you can see in these examples, ggplot tries to be smart about the mapping you ask.\nIt automatically sets the x and y ranges to the values in your data.\nIt mapped the size such that there are small and large points, but not e.g. a point so large that it would dominate the graph.\nFor the colour, for interval variables it created a colour scale, while for a categorical variable it automatically assigned a colour to each group.\n\nOf course, each of those choices can be customized, and sometimes it makes a lot of sense to do so.\nFor example, you might wish to use red for republicans and blue for democrats, if your audience is used to those colors; or you may wish to use grayscale for an old-fashioned paper publication.\nWe'll explore more options in a later tutorial, but for now let's be happy that ggplot does a lot of work for us!\n\n# Bar plots\n\nAnother frequently used plot is the bar plot. \nBy default, R bar plots assume that you want to plot a histogram, e.g. the number of occurences of each group.\nAs a very simple example, the following plots the number of states that are growing or stable in population:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = facts_state) + \n  geom_bar(aes(x = growth))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\nFor a more interesting plot, let's plot the votes per Republican candidate in the New Hampshire primary.\nFirst, we need to download the per-county data, summarize it per state, and filter to only get the NH results for the Republican party:\n(see the previous tutorials on [Data Transformations](R-tidy-5-transformation.md) and [Joining data](R-tidy-13a-joining.md) for more information if needed)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl_state <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/primary_results.csv\"\n\nresults_state <- read_csv(url_state) %>% \n  group_by(state, party, candidate) %>% \n  summarize(votes=sum(votes))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 24611 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): state, state_abbreviation, county, party, candidate\ndbl (3): fips, votes, fraction_votes\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n`summarise()` has grouped output by 'state', 'party'. You can override using the `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nnh_gop <- results_state %>% \n  filter(state == \"New Hampshire\" & party == \"Republican\")\nnh_gop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n# Groups:   state, party [1]\n  state         party      candidate       votes\n  <chr>         <chr>      <chr>           <dbl>\n1 New Hampshire Republican Ben Carson       6509\n2 New Hampshire Republican Carly Fiorina   11706\n3 New Hampshire Republican Chris Christie  21069\n4 New Hampshire Republican Donald Trump   100406\n5 New Hampshire Republican Jeb Bush        31310\n6 New Hampshire Republican John Kasich     44909\n7 New Hampshire Republican Marco Rubio     30032\n8 New Hampshire Republican Ted Cruz        33189\n```\n\n\n:::\n:::\n\n\n\n\nNow, let's make a bar plot with votes (y) per candidate (x).\nWe use `geom_col` here, which means that we provide a `y` aesthetic rather than having ggplot calculate it from the frequencies. \nEquivalently, we could have users `geom_bar(stat=\"identity\")` to create a bar plot with an 'identity' statistics.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_col(aes(x=candidate, y=votes))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n## Setting graph options\n\nSome options, like labels, legends, and the coordinate system are graph-wide rather than per layer. You add these options to the graph by adding extra functions to the call.\nFor example, we can use coord_flip() to swap the x and y axes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_col(aes(x=candidate, y=votes)) +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\nYou can also reorder categories with the `fct_reorder` function, for example to sort by number of votes. Also, let's add some colour (just because we can!):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_bar(aes(x=fct_reorder(candidate, votes), y=votes, fill=candidate), \n           stat='identity') + \n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n(Note: this works because ggplot assumes all labels are `factor`s, which have an ordering;\nyou can use other functions from the `forcats` package (generally starting with `fct_`) to do other things such\nas reversing the order, manually specifying the order, etc).\n\nThis is getting somewhere, but the y-axis label is not very pretty and we don't need guides for the fill mapping. This can be remedied by more graph-level options.\nAlso, we can use a `theme` to alter the appearance of the graph, for example using the minimal theme:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nh_gop) + \n  geom_bar(aes(x=reorder(candidate, votes), y=votes, fill=candidate), \n           stat='identity') + \n  coord_flip() + \n  xlab(\"Candidate\") + \n  guides(fill=\"none\") + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n## Grouped bar plots\n\nWe can also add groups to bar plots. \nFor example, we can set the x category to state (taking only NH and IA to keep the plot readable), and then group by candidate:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngop2 <- results_state %>% \n  filter(party == \"Republican\" & (state == \"New Hampshire\" | state == \"Iowa\")) \nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\nBy default, the groups are stacked. This can be controlled with the position parameter, which can be `dodge` (for grouped bars) or `fill` (stacking to 100%): \n(note that the position is a constant, not an aesthetic mapping, so it goes outside the `aes` argument)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate), position='dodge')\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(gop2) + geom_col(aes(x=state, y=votes, fill=candidate), position='fill')\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n:::\n\n\n\n\nOf course, you can also make the grouped bars add up to 100% by computing the proportion manually,\nwhich can give you a bit more control over the process.\n\nNote that the example below pipes the preprocessing output directly into the `ggplot` command,\nthat is, it doesn't create a new temporary data set like `gop2` above.\nThis is entirely a stylistic choice, but can be useful for operations that are only intended for a single visualization. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngop2 %>% \n  group_by(state) %>% \n  mutate(vote_prop=votes/sum(votes)) %>%\n  ggplot() + \n    geom_col(aes(x=state, y=vote_prop, fill=candidate), position='dodge') + \n    ylab(\"Votes (%)\")\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\nNote that where `group_by %>% summarize` replaces the data frame by a summarization, `group_by %>% mutate` adds a column to the existing data frame, using the grouped values for e.g. sums. See our tutorial on [Data Summarization](R-tidy-5b-groupby.md) for more details.\n\n# Line plots\n\nFinally, another frequent graph is the line graph. \nFor example, we can plot the ascendancy of Donald Trump by looking at his vote share over time. \nFirst, we combine the results per state with the primary schedule: (see the tutorial on [Joining data](R-tidy-13a-joining.md))\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dataset 1: dates for each primary\nurl2 <- \"https://raw.githubusercontent.com/houstondatavis/data-jam-august-2016/master/csv/primary_schedule.csv\"\nschedule  <- read_csv(url2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 113 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): date, state, party, type\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nschedule <- schedule %>% \n  mutate(date = as.Date(date, format=\"%m/%d/%y\"))\nschedule\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 113 × 4\n   date       state          party    type               \n   <date>     <chr>          <chr>    <chr>              \n 1 2016-02-01 Iowa           Democrat Semi-open caucus   \n 2 2016-02-09 New Hampshire  Democrat Semi-closed primary\n 3 2016-02-20 Nevada         Democrat Closed caucus      \n 4 2016-02-27 South Carolina Democrat Open primary       \n 5 2016-03-01 Alabama        Democrat Open primary       \n 6 2016-03-01 American Samoa Democrat Closed caucus      \n 7 2016-03-01 Arkansas       Democrat Open primary       \n 8 2016-03-01 Colorado       Democrat Closed caucus      \n 9 2016-03-01 Georgia        Democrat Open primary       \n10 2016-03-01 Massachusetts  Democrat Semi-closed primary\n# ℹ 103 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# dataset 2: vote share for trump for each state\ntrump = results_state %>% \n  group_by(state, party) %>% \n  mutate(vote_prop=votes/sum(votes)) %>% \n  filter(candidate==\"Donald Trump\")\ntrump\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 46 × 5\n# Groups:   state, party [46]\n   state       party      candidate      votes vote_prop\n   <chr>       <chr>      <chr>          <dbl>     <dbl>\n 1 Alabama     Republican Donald Trump  371735     0.444\n 2 Alaska      Republican Donald Trump    7346     0.335\n 3 Arizona     Republican Donald Trump  249916     0.574\n 4 Arkansas    Republican Donald Trump  133144     0.336\n 5 California  Republican Donald Trump 1174829     0.786\n 6 Connecticut Republican Donald Trump  123367     0.591\n 7 Delaware    Republican Donald Trump   42472     0.626\n 8 Florida     Republican Donald Trump 1077221     0.473\n 9 Georgia     Republican Donald Trump  501707     0.393\n10 Hawaii      Republican Donald Trump    5677     0.429\n# ℹ 36 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# join the two data sets\ntrump <- left_join(trump, schedule) %>% \n  group_by(date) %>% \n  summarize(vote_prop = mean(vote_prop))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(state, party)`\n```\n\n\n:::\n\n```{.r .cell-code}\ntrump\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 17 × 2\n   date       vote_prop\n   <date>         <dbl>\n 1 2016-02-01     0.243\n 2 2016-02-09     0.360\n 3 2016-02-20     0.325\n 4 2016-02-23     0.461\n 5 2016-03-01     0.341\n 6 2016-03-05     0.343\n 7 2016-03-08     0.397\n 8 2016-03-15     0.413\n 9 2016-03-22     0.357\n10 2016-04-05     0.360\n11 2016-04-19     0.604\n12 2016-04-26     0.602\n13 2016-05-03     0.546\n14 2016-05-10     0.752\n15 2016-05-17     0.666\n16 2016-05-24     0.789\n17 2016-06-07     0.770\n```\n\n\n:::\n:::\n\n\n\n\nTake a minute to inspect the code above, and try to understand what each line does! \nThe best way to do this is to inspect the output of each line, and trace back how that output is computed based on the input data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(trump) + geom_line(aes(x = date, y = vote_prop))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can do the same for multiple candidates as well, for example for the democratic candidates:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndems <- results_state %>% \n  filter(party == \"Democrat\") %>% \n  left_join(schedule)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(state, party)`\n```\n\n\n:::\n\n```{.r .cell-code}\ndems <- dems %>% \n  group_by(date, candidate) %>% \n  summarize(votes = sum(votes)) %>% \n  mutate(vote_prop = votes / sum(votes))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'date'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(dems) + \n  geom_line(aes(x = date, y = vote_prop, colour = candidate))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\nBonus question: in the code for Trump, the proportion was calculated in two statements (first per state, then per date), but in this code it is calculated only per date. \nHow does that matter? Is either calculation more correct than the other?\n\n# Multiple 'faceted' plots\n\nJust to show off some of the possibilities of ggplot, let's make a plot of all republican primary outcomes on Super Tuesday (March 1st):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuper <- results_state %>% \n  left_join(schedule) %>% \n  filter(party == \"Republican\" & date == \"2016-03-01\") %>% \n  group_by(state) %>% \n  mutate(vote_prop = votes/sum(votes))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(state, party)`\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(super) + \n  geom_bar(aes(x = candidate, y = vote_prop), \n           stat = 'identity') + \n  facet_wrap(~state, nrow = 3) + \n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n\nNote ~facet_wrap~ wraps around a single facet. You can also use ~facet_grid() to specify separate variables for rows and columns\n\n# Themes\n\nCustomization of things like background colour, grid colour etc. is handled by themes. \n`ggplot` has two built-in themes: `theme_grey` (default) and `theme_bw` (for a more minimal theme with white background). \nThe package ggthemes has some more themes, including an 'economist' theme (based on the newspaper).\nTo use a theme, simply add it to the plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggthemes)\nggplot(trump) + \n  geom_line(aes(x = date, y = vote_prop)) + \n  theme_economist()\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n\nYou can also modify any of the theming elements yourself (check the help for `theme()` for more information):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(trump) + \n  geom_line(aes(x = date, y = vote_prop)) + \n  theme_economist() +\n  theme(panel.grid.major.y = element_line(colour=\"lightblue\"))\n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n\nSome links for learning more about themes:\n\n + https://ggplot2.tidyverse.org/reference/theme.html\n + https://www.datanovia.com/en/blog/ggplot-themes-gallery\n + http://rstudio-pubs-static.s3.amazonaws.com/284329_c7e660636fec4a42a09eed968dc47f32.html\n\n# Plotting maps\n\nGeographic information can be plotted in `ggplot` much like scatter plots,\nsimply using longitude and lattitude as x and y. \nOften, we want to plot data on an actual map of (part of) the world,\nfor example to plot locations of tweets or colour a map with information per country or state.\n\nIn `ggplot` this is accomplished by plotting the shapes of the countries. The package includes shape\ndata for the US, the world, and some countries like France, but unfortunately not EU or Germany. The maps originate from the `maps` package, so you can check their documentation to see what countries are included. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nstates <- map_data('state')\nhead(states)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       long      lat group order  region subregion\n1 -87.46201 30.38968     1     1 alabama      <NA>\n2 -87.48493 30.37249     1     2 alabama      <NA>\n3 -87.52503 30.37249     1     3 alabama      <NA>\n4 -87.53076 30.33239     1     4 alabama      <NA>\n5 -87.57087 30.32665     1     5 alabama      <NA>\n6 -87.58806 30.32665     1     6 alabama      <NA>\n```\n\n\n:::\n:::\n\n\n\n\nThis basically tells ggplot what lines to draw to form a state. If a state is not contiguous it will contain subregions resulting in multiple polygons.\n\nWe can immediately plot this data, using the `geom_polygon` to plot shapes. We specify x and y as longitude and lattitude, fill by state, and make the state borders white. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = states) + \n  geom_polygon(aes(x = long, y = lat, fill = region, group = group), \n               color = \"white\") + \n  coord_fixed(1.3) + \n  guides(fill=\"none\")  \n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n\nNote: the last line fixes the aspect ratio to 1.3 and prevents a per-state legend (guide) from being plotted.\n\n\nThis example coloured the states as a non-informative nominal variable. We can also colour by our own data, for example by percentage white ethnicity:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates <- facts_state %>% \n  mutate(region=tolower(area_name)) %>% \n  select(region, white) %>% \n  inner_join(states)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(region)`\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = states) + \n  geom_polygon(aes(x = long, y = lat, fill = white, group = group), color = \"white\") + \n  coord_fixed(1.3) + theme_void() + \n  ggtitle(\"Percentage white population per state\") \n```\n\n::: {.cell-output-display}\n![](3_visualization_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::",
    "supporting": [
      "3_visualization_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}